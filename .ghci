:set +s
:set +t
:set -W
:set -XOverloadedStrings
:set editor ec
:set prompt "Î»: "
:def! . readFile
:def! g (\_ -> return ":. .ghci\n")

:set -Wall

import qualified Data.List as DL
import Data.List.Split
import qualified Data.List.Split as DL
import qualified Data.ByteString.Lazy as L
import qualified Data.ByteString as B
import qualified Data.ByteString.Char8 as B8
import qualified Data.Map.Strict as M
import Data.Word
import Text.Printf
import Data.Either
import Data.Text.Read
import Data.Text
import Data.Time
import Data.Maybe
import Hakyll
import qualified Hakyll as H
import Network.HTTP.Client
import Text.HTML.TagSoup

ts@(UTCTime d dt) <- getCurrentTime

s <- DL.sort <$> loadScreenings

let w = Schedule s
let w' = computeDeps w
let s = scheduleScreenings w'
f <- DL.sort <$> loadFilms
let catalog = f
let (f0:f1:f2:f3:f4:f5:f6:f7:f8:f9:_) = f
let (s0:s1:s2:s3:s4:s5:s6:s7:s8:s9:_) = s
let scs@(sc1:sc2:sc3:_) = viewableSchedulesFor w (DL.take 10 f)
let s' = DL.concat $ fmap scheduleScreenings $ DL.take 1 $ viewableSchedulesFor w (DL.take 20 f)
let p = mapM_ print

let toIds t = fmap (fmap (fmap screeningId)) $ t
let toSt t = fmap (fmap (fmap showtime)) $ t
let sl = screeningListsFor w (DL.take 10 f)
let slc = DL.chunksOf 2 sl
let r = DL.take 3 . DL.filter disjoint . sequence

let f' = DL.foldr (\a b -> (fmap DL.concat . sequence $ a) : b) [] 

let v = fmap sequence (DL.chunksOf 2 sl)

let v' = f' (DL.chunksOf 2 v)
let v'' = f' (DL.chunksOf 2 v')
let v''' = f' (DL.chunksOf 2 v'')
let v'''' = f' (DL.chunksOf 2 v''')

run = hakyll . match "posts/*"

:def! rg (\_ -> return ":r\n:g\n")

:def! ra (\_ -> return ":set -w\n:l test/unit/Runner.hs\nrun")

:def! Ra (\_ -> return ":ra")

:def! rd (\t -> (return (":def! r (\\_ -> return (\":rt " ++ t ++ "\"))")))

:def! R (\_ -> return ":set -w\n:r\n:g\n")

:def! rt (\_ -> return (":l src/test.hs\nrunTestTT tests"))

:def! b (\_ -> return (":l src/main.hs\n:set args build\nmain"))
:def! rb (\_ -> return (":l src/main.hs\n:set args rebuild\nmain"))

